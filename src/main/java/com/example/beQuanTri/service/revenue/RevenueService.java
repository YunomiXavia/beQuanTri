package com.example.beQuanTri.service.revenue;

import com.example.beQuanTri.constant.PredefineStatus;
import com.example.beQuanTri.dto.response.order.OrderItemsResponse;
import com.example.beQuanTri.entity.collaborator.Collaborator;
import com.example.beQuanTri.entity.commission.Commission;
import com.example.beQuanTri.entity.order.OrderItems;
import com.example.beQuanTri.entity.revenue.DailyRevenue;
import com.example.beQuanTri.entity.order.Order;
import com.example.beQuanTri.helper.utils.DateConversionUtil;
import com.example.beQuanTri.mapper.order.OrderMapper;
import com.example.beQuanTri.repository.collaborator.CollaboratorRepository;
import com.example.beQuanTri.repository.collaborator.CommissionRepository;
import com.example.beQuanTri.repository.order.OrderRepository;
import com.example.beQuanTri.repository.revenue.DailyRevenueRepository;
import com.example.beQuanTri.service.collaborator.CollaboratorService;
import com.example.beQuanTri.service.status.StatusService;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Service class for handling revenue-related operations,
 * including daily revenue calculation and revenue queries.
 */
@Builder
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
@Service
public class RevenueService {

    // Dependencies
    OrderRepository orderRepository;
    DailyRevenueRepository dailyRevenueRepository;
    CommissionRepository commissionRepository;
    CollaboratorService collaboratorService;
    CollaboratorRepository collaboratorRepository;
    StatusService statusService;
    OrderMapper orderMapper;

    /**
     * Scheduled job to calculate the daily revenue at midnight every day.
     *
     * @return the calculated daily revenue entity
     */
    @Scheduled(cron = "0 0 0 * * *")
    public DailyRevenue calculateAndSaveDailyRevenue() {
        log.info("In Method calculateDailyRevenue");

        // Get today's date
        LocalDate today = LocalDate.now();

        // Calculate total revenue for today
        double totalRevenueToday = orderRepository
                .findAllByOrderDateAndStatus(
                        DateConversionUtil.convertLocalDateToDate(today),
                        statusService.findByStatusName(PredefineStatus.COMPLETE)
                )
                .stream()
                .mapToDouble(Order::getTotalAmount)
                .sum();

        // Create a new DailyRevenue entity
        DailyRevenue dailyRevenue = DailyRevenue.builder()
                .date(today)
                .totalRevenue(totalRevenueToday)
                .build();

        // Save and return the daily revenue
        return dailyRevenueRepository.save(dailyRevenue);
    }

    /**
     * Retrieves the daily revenue records between two given dates with pagination.
     *
     * @param startDate the start date of the period
     * @param endDate   the end date of the period
     * @param pageable  the pagination information
     * @return a paginated list of daily revenue records
     */
    @PreAuthorize("hasRole('Admin')")
    public Page<DailyRevenue> fetchDailyRevenueBetweenDates(
            LocalDate startDate,
            LocalDate endDate,
            Pageable pageable) {

        log.info("In Method fetchDailyRevenueBetweenDates");

        // Validate the date range
        if (startDate.isAfter(endDate)) {
            throw new IllegalArgumentException("Start date must be before or equal to end date.");
        }

        // Retrieve revenue records between the given dates with pagination
        return dailyRevenueRepository.findByDateBetween(startDate, endDate, pageable);
    }

    /**
     * Fetches the total revenue generated by a specific collaborator.
     *
     * @param collaboratorId the ID of the collaborator
     * @return the total revenue as a double
     */
    @PreAuthorize("hasRole('Collaborator') or hasRole('Admin')")
    public double fetchCollaboratorTotalRevenue(
            String collaboratorId) {
        log.info("Calculating revenue for collaborator: {}", collaboratorId);

        return orderRepository.findByCollaboratorId(collaboratorId)
                .stream()
                .mapToDouble(Order::getTotalAmount)
                .sum();
    }

    /**
     * Fetches the total commission earned by a specific collaborator.
     *
     * @param collaboratorId the ID of the collaborator
     * @return the total commission as a double
     */
    @PreAuthorize("hasRole('Admin')")
    public double fetchCollaboratorTotalCommission(String collaboratorId) {
        log.info("Calculating commission for collaborator: {}", collaboratorId);

        return commissionRepository.findByCollaboratorId(collaboratorId)
                .stream()
                .mapToDouble(Commission::getCommissionAmount)
                .sum();
    }

    /**
     * Calculates the total revenue for a collaborator including their earned commission.
     *
     * @param collaboratorId the collaborator's ID
     * @return the total revenue including commission
     */
    @PreAuthorize("hasRole('Collaborator') or hasRole('Admin')")
    public double fetchCollaboratorTotalRevenueIncludingCommission(String collaboratorId) {
        log.info("In Method calculateTotalRevenueWithCommission");

        Collaborator collaborator = collaboratorService.findCollaboratorById(collaboratorId);

        return collaborator.getTotalCommissionEarned()
                / collaborator.getCommissionRate();
    }

    /**
     * Get service dates for all products in an order with pagination.
     *
     * @param orderId  the ID of the order
     * @param pageable the pagination information
     * @return a paginated list of order items with their service dates
     */
    public Page<OrderItemsResponse> getServiceDatesByOrderId(String orderId, Pageable pageable) {
        log.info("In Method getServiceDatesByOrderId");

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new IllegalArgumentException("Order not found with ID: " + orderId));

        // Assuming that the number of OrderItems could be large and needs pagination
        List<OrderItemsResponse> serviceDates = new ArrayList<>();
        for (OrderItems orderItem : order.getOrderItems()) {
            Date startDate = order.getOrderDate();
            Date endDate = DateConversionUtil.addDays(startDate, orderItem.getProduct().getSubscriptionDuration());
            orderItem.setExpiryDate(endDate);

            // Convert to response format
            serviceDates.add(orderMapper.toOrderItemsResponse(orderItem));
        }

        // Manual pagination since OrderItems are part of a single Order
        int pageSize = pageable.getPageSize();
        int currentPage = pageable.getPageNumber();
        int startItem = currentPage * pageSize;
        List<OrderItemsResponse> list;

        if (order.getOrderItems().size() < startItem) {
            list = new ArrayList<>();
        } else {
            int toIndex = Math.min(startItem + pageSize, order.getOrderItems().size());
            list = serviceDates.subList(startItem, toIndex);
        }

        return new org.springframework.data.domain.PageImpl<>(list, pageable, serviceDates.size());
    }
}
